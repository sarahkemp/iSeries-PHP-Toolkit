<?php
include_once 'ToolkitServiceSet.php';
include_once 'ToolkitServiceXML.php';
include_once 'ToolkitServiceParameter.php';

define('CONFIG_FILE', 'toolkit.ini');

class ToolkitService {

	const VERSION = '1.5.0';
	// version number for front-end PHP toolkit

	/* TODO use inputXml and outputXml to make this class more flexibly OO-like.
	 * Fewer strings copied around.
	 * Better would be to use a Request object that has a connection.
	 * There could be multiple Request objects even if only one connection.
	 * Each request object could have its own input and output.
	 */
	protected $XMLWrapper = null;
	protected $conn = NULL;
	// connection to database or other transport

	// TODO create methods to set (separately and all at once) and get errors, akin
	// to what was done for DB module.
	// Test ability to retrieve program errors and text.
	protected $error = '';
	protected $cpfErr = '';
	protected $errorText = '';

	protected $db2 = false;
	protected $db = null;

	protected $_i5NamingFlag = DB2_I5_NAMING_OFF;
	// default with value of 0. Other value is DB2_I5_NAMING_ON.
	protected $_schemaSep = '.';
	// schema separator. A dot or slash
	protected $_validSeparators = array(
		'.',
		'/'
	);

	protected $_outputVarsToExport = array();
	protected $_isPersistent = false;

	protected $_isCw = false;
	// whether the CW is used for this instance.

	static protected $_config;
	// config options from INI file. Accessed by static method getConfigValue();

	// brought over from CW
	protected $joblog = '';
	protected $_privateConnNum = null;
	protected $_isNewConn = true;
	// default to "new/true" because it's safest. new means app perhaps should
	// initalize job.
	// In case of error, look for CPFs generated by specific other programs.
	// E.g. if userid is wrong when calling QSYGETPH, the CPF may be reported by
	// program QSYPHDL in joblog.
	// TODO would be better specified in external file or in INI.
	protected $_cpfMapping = array(
		'QSYRUSRI' => array('QLIROHDL'),
		'QSYGETPH' => array('QSYPHDL')
	);

	// options that can be set at any time
	// Set them with setOptions or setToolkitServiceParams
	// Get them with getOption or getToolkitServiceParam
	protected $_options = array(
		'plug' => 'iPLUG512K', //for ibm_db2. for  odbc $plug='iPLUGR512K'.  consider 4K
		// with small data
		'plugSize' => '512K', // 4K, 32K, 512K, 65K, 512K, 1M, 5M, 10M, 15M
		'plugPrefix' => 'iPLUG', // iPLUG (ibm_db2) or iPLUGR (odbc)
		'XMLServiceLib' => XMLSERVICELIB,
		'v5r4' => false, // whether to ask XMLSERVICE to carefully use features that v5r4
		// can handle
		'sbmjobParams' => 'ZENDSVR/ZSVR_JOBD/XTOOLKIT', // in test mode, use
		// QSYS/QSRVJOB/XTOOLKIT. Also see PLUGCONF1 and 2
		'debug' => false,
		'debugLogFile' => '/usr/local/zendsvr/share/ToolkitApi/debug.log',
		// CCSID/Hex at a global/request level. These properties are also defined at a
		// parameter object level.
		'ccsidBefore' => '',
		'ccsidAfter' => '',
		'useHex' => false,
		'paseCcsid' => '', // PASE CCSID for <sh> pase such as WRKACTJOB
		'trace' => false, // whether to enable XMLSERVICE internal log
		'sbmjobCommand' => '', // optional complete override of SBMJOB command when new
		// toolkit job is submitted
		'prestart' => false,
		'stateless' => false,
		'performance' => false, // whether to enable performance collection (not fully
		// implemented)
		'idleTimeout' => '', // created for Compat. Wrapper (CW)
		'cdata' => true, // whether to ask XMLSERVICE to wrap its output in CDATA to
		// protect reserved XML characters
		'internalKey' => XMLINTERNALKEY, // consistent naming style
		'encoding' => "ISO-8859-1", /*English. Hebrew:ISO-8859-8 */
		'schemaSep' => '.', // schema separator. A dot or slash
		'parseOnly' => false, // do not run any program; simply parse, expand dim if
		// necessary, and return.
		'parseDebugLevel' => 1, // 1-9 debug level when in parseOnly mode
		'license' => false, // true to receive license/version information
		'transport' => false, // check proc call speed (no XML calls)
		'performance' => false, // get performance of previous call
		'dataStructureIntegrity' => false, // New in 1.4.0. Specify true to preserve
		// integrity of data structures. If false (default), explode inner values out of
		// the ds.
		'arrayIntegrity' => false, // New in 1.4.0. Specify true to preserve integrity of
		// arrays (to create true named arrays, not merely sequentially numbered
		// elements).
		'customControl' => '', // any string you want. Will be concatenated to control
		// key string after a single space.
		'transportType' => 'ibm_db2', // can override in getInstance constructor as well
		'httpTransportUrl' => '', // for HTTP REST transport
	);

	// plug size to bytes cross-reference
	protected $_dataSize = array(
		"4K" => 4096,
		"32K" => 32000,
		"65K" => 65000,
		"512K" => 512000,
		"1M" => 1000000,
		"5M" => 5000000,
		"10M" => 10000000,
		"15M" => 15000000,
	);

	static protected $instance = NULL;

	// need to define this so we get Cw object and not parent object
	static function getInstance($databaseNameOrResource = '*LOCAL', $userOrI5NamingFlag = '', $password = '', $transportType = '', $isPersistent = false) {
		// if instance hasn't been created yet, create one
		if (self::$instance == NULL) {
			$toolkitService = __CLASS__;
			self::$instance = new $toolkitService($databaseNameOrResource, $userOrI5NamingFlag, $password, $transportType, $isPersistent);
		}

		if (self::$instance) {
			// we have an instance
			return self::$instance;
		} else {
			// some problem
			// only if CW    	setError(I5_ERR_NOTCONNECTED, I5_CAT_PHP, 'Cannot get a
			// connection', 'Cannot get a connection');
			return false;
		} //(if (parent::$instance))
	}//(getInstance)

	public function __destruct() {
		/* call to disconnect()  function to down connection */
		if ($this->conn == null)
			self::$instance = NULL;

	}

	/**
	 * Return true if an instance of this object has already been created.
	 * Return false if no instance has been instantiated.
	 *
	 * Useful when users need to know if a "toolkit connection" has already been
	 * made.
	 * Usage:
	 * $isConnected = ToolkitService::hasInstance();
	 *
	 * @return boolean
	 */
	static function hasInstance() {

		if (isset(self::$instance) && is_object(self::$instance)) {
			return true;
		} else {
			return false;
		}
	}//(hasInstance())

	/**
	 * Return true if we are in debug mode
	 * Return false if not
	 *
	 * Usage:
	 * $isDebug= $this->isDebug();
	 *
	 * @return boolean
	 */
	protected function isDebug() {
		return $this->getOption('debug');

	}//(isDebug())

	// if passing an existing resource and naming, don't need the other params.
	protected function __construct($databaseNameOrResource, $userOrI5NamingFlag = '', $password = '', $transportType = '', $isPersistent = false) {

		// get settings from INI file
		// TODO change getConfigValue to get many at one time
		$xmlServiceLib = $this->getConfigValue('system', 'XMLServiceLib', 'ZENDSVR');
		$debug = $this->getConfigValue('system', 'debug', false);
		$debugLogFile = $this->getConfigValue('system', 'debugLogFile', false);
		$encoding = $this->getConfigValue('system', 'encoding', 'ISO-8859-1');
		// XML encoding
		$sbmjobParams = $this->getConfigValue('system', 'sbmjob_params');
		$parseOnly = $this->getConfigValue('testing', 'parse_only', false);
		$parseDebugLevel = $this->getConfigValue('testing', 'parse_debug_level', null);

		// set service parameters to use in object.
		// Here are the params that will always be present.
		$serviceParams = array(
			'XMLServiceLib' => $xmlServiceLib,
			'debug' => $debug,
			'debugLogFile' => $debugLogFile,
			'encoding' => $encoding,
			'parseOnly' => $parseOnly,
			'parseDebugLevel' => $parseDebugLevel
		);

		// Optional params. Don't specify if not given in INI.
		$optionalSystemParamNames = array(
			'v5r4',
			'ccsidBefore',
			'ccsidAfter',
			'useHex',
			'paseCcsid',
			'trace',
			'dataStructureIntegrity',
			'arrayIntegrity'
		);
		foreach ($optionalSystemParamNames as $optionalSystemParamName) {
			$val = $this->getConfigValue('system', $optionalSystemParamName);
			if ($val) {
				$serviceParams[$optionalSystemParamName] = $val;
			}

		}//(foreach ($optionalSystemParamNames)

		// More optional params. From [transport] section
		$optionalSystemParamNames = array(
			'httpTransportUrl',
			'plugSize'
		);
		if (!$transportType) {
			// transport type (http, ibm_db2, odbc) not passed into constructor. get from INI
			// if avail.
			$optionalSystemParamNames[] = 'transportType';
		} else {
			// transport type was passed to constructor. Use it directly in param array.
			$serviceParams['transportType'] = $transportType;
		}//(if (!$transportType))

		// look up the needed options in INI file.
		foreach ($optionalSystemParamNames as $optionalSystemParamName) {
			$val = $this->getConfigValue('transport', $optionalSystemParamName);
			if ($val) {
				$serviceParams[$optionalSystemParamName] = $val;
			}

		}//(foreach ($optionalSystemParamNames)

		if ($sbmjobParams) {
			// optional. Don't specify if not given in INI.
			$serviceParams['sbmjobParams'] = $sbmjobParams;
		}//(if sbmjobParams)

		// set up options in this object. Includes debugging, logging, transport.
		$this->setOptions($serviceParams);

		// get transport type from options, wherever it came from.
		$transportType = $this->getOption('transportType');

		if ($this->isDebug()) {
			$this->debugLog("Creating new conn with database: '$databaseNameOrResource', user or i5 naming flag: '$userOrI5NamingFlag', transport: '$transportType', persistence: '$isPersistent'\n");
		}

		/*
		 * try {
		 toolkit->callsomething($xml);
		 echo 'Never get here';
		 }
		 catch (Exception $e)
		 {
		 echo 'Exception caught: ',  $e->getCode(), " : ", $e->getMessage(),  "\n";
		 }
		 */

		$this->chooseTransport($transportType);

		$transport = $this->getTransport();

		// if db resource was passed in
		if (is_resource($databaseNameOrResource)) {
			// we already have a db connection, passed in by user.
			$conn = $databaseNameOrResource;
			$this->_i5NamingFlag = $userOrI5NamingFlag;
			// 0 or 1
			// slash if true, dot if false.
			$schemaSep = ($this->_i5NamingFlag) ? '/' : '.';
			$this->setOptions(array('schemaSep' => $schemaSep));

			if ($this->isDebug()) {
				$this->debugLog("Re-using an existing db connection with schema separator: $schemaSep");
			}

			// TODO could check type of object
		} elseif ($transportType == 'http') {

			$databaseName = $databaseNameOrResource;
			$user = $userOrI5NamingFlag;
			$conn = $transport->connect($databaseName, $user, $password);

		} else {

			// A DB transport, yet a resource was not passed. Create a new db connection.
			$databaseName = $databaseNameOrResource;
			$user = $userOrI5NamingFlag;
			if ($this->isDebug()) {
				$this->debugLog("Going to create a new db connection at " . date("Y-m-d H:i:s") . ".\n");
				$startCreate = microtime(true);
			}
			$this->setIsPersistent($isPersistent);
			$conn = $this->db->connect($databaseName, $user, $password, array('persistent' => $this->getIsPersistent()));
			if ($this->isDebug()) {
				$durationCreate = sprintf('%f', microtime(true) - $startCreate);
				$this->debugLog("Did create a new db connection in $durationCreate seconds.");
			}

		}
		//(is_resource)

		if (!$conn) {
			// added code in addition to message.
			// need to get TRANSPORT's way to get an error.
			// TODO add other transports, soap, etc. not just db.
			// Should set error in the transport (db2),
			// a common error routine in the base class, let's say.
			// The subclasses can say why.
			// make generic "geterrorcode" and "geterrormessage" methods.
			// base class can have transportStateErrorMessage and tSECode
			// and the adapters fill those in. Not sql-specific.

			// Note: SQLState 08001 (with or without SQLCODE=-30082) usually means invalid
			// user or password. This is true for DB2 and ODBC.
			$sqlState = $this->db->getErrorCode();
			$this->error = $this->db->getErrorMsg();

			$this->debugLog("\nFailed to connect. sqlState: $sqlState. error: $this->error");
			// added sqlstate
			throw new Exception($this->error, $sqlState);
		}
		$this->conn = $conn;

		return $this;
		// for fluent interface

	}//(protected function __construct)

	public function __clone() {
		throw new Exception(" Use getInstance() function according to create a new ToolkitService object");
	}

	// whether we're using CW (compatibility wrapper) or not
	public function setIsCw($isCw) {
		$this->_isCw = $isCw;
	}//(function setIsCw)

	public function getIsCw() {
		return $this->_isCw;
	}//(function getIsCw()

	// return array of valid plug sizes.
	// public method in case an application wishes to validate.
	public function validPlugSizes() {
		return array_keys($this->_dataSize);
	}///(validPlugSizeArray)

	// valid plug sizes separated by commas. Useful for informational messages.
	protected function validPlugSizeList() {
		return implode($this->validPlugSizes(), ', ');
	}

	// return size in bytes based on plugSize.
	protected function plugSizeToBytes($plugSize) {

		// return size in bytes based on plugSize.
		if (isset($this->_dataSize[$plugSize])) {
			return $this->_dataSize[$plugSize];
		}

		throw new Exception("plugSize '$plugSize' is not valid. Try one of these: " . $this->validPlugSizeList);

	}//(protected function plugSizeToBytes($size) )

	protected function setTransport($transportObject) {
		$this->_transport = $transportObject;
	}//(protected function setTransport)

	protected function getTransport() {
		return $this->_transport;
	}

	protected function chooseTransport($transportName = '') {

		if ($transportName == 'http') {
			include_once 'httpsupp.php';
			$transport = new httpsupp();
			$this->setTransport($transport);

		} else {
			// not http. Assume it's one of the db transports
			$this->setDb($transportName);
			// ibm_db2, odbc, http
		} //(if ($transportName == 'http'))

	}//(protected function chooseTransport($transportName = ''))

	// transport type is same as db extension name when a db transport is used.
	protected function setdb($transportType = '') {
		$transportType = trim($transportType);

		// if extension is specified, use it; else use default db.
		$extensionName = ($transportType) ? $transportType : DBPROTOCOL;

		if (!extension_loaded($extensionName)) {
			throw new Exception("Extension $extensionName not loaded.");
		}

		// extension is loaded. Set up db transport objects.

		if ($extensionName === 'ibm_db2') {

			$this->setOptions(array('plugPrefix' => 'iPLUG'));
			include_once 'Db2supp.php';
			$this->db = new db2supp();

			$this->setDb2();
			// not used in toolkit anymore but keep for backwards compat.

		} elseif ($extensionName === 'odbc') {

			//for odbc will be different default stored procedure call
			$this->setOptions(array('plugPrefix' => 'iPLUGR'));
			// "R" = "result set" which is how ODBC driver returns param results
			include_once 'Odbcsupp.php';
			$this->db = new odbcsupp();

		}
		//(extension name)

		// transport, too, to be generic
		$this->setTransport($this->db);

		return;

	}//(function setdb)

	// Also alias setOptions()
	public function setToolkitServiceParams(array $XmlServiceOptions) {
		// copy incoming options to new array that we can safely manipulate
		$options = $XmlServiceOptions;

		// special cases first

		/* If sbmjobParams is present, it must contain at least one slash. If not, do not
		 * process it.
		 *  The slash implies that subsystem name and subsytem decscription (and,
		 * optionally, job name)
		 *  are present in the string
		 */
		if (isset($options['sbmjobParams']) && !strstr($options['sbmjobParams'], "/")) {
			unset($options['sbmjobParams']);
		}//(if sbmjobParams is set but no slash)

		// if a plug name is passed in, it overrides plugPrefix and plugSize.
		if (isset($options['plug']) && $options['plug']) {

			// TODO enumerate plug prefixes centrally, tied to db extension name, at top of
			// this class
			$possiblePrefixes = array(
				'iPLUG',
				'iPLUGR'
			);
			$options['plugSize'] = str_replace($possiblePrefixes, '', $options['plug']);
			// remove prefix to get size
			$options['plugPrefix'] = str_replace($options['plugSize'], '', $options['plug']);
			// remove size to get prefix

		}//(plug)

		// encoding provided but it's blank
		if (isset($options['encoding']) && !$options['encoding']) {
			unset($options['encoding']);
		}

		// verify that schemaSep is a valid character for this purpose
		if (isset($options['schemaSep']) && !in_array($options['schemaSep'], $this->_validSeparators)) {
			unset($options['schemaSep']);
		}

		// handle case sensitivity. Put value in index of proper camel casing
		if (isset($options['InternalKey'])) {
			$options['internalKey'] = $options['InternalKey'];
		}

		// now set all in a generic fashion
		// loop through all options provided in param
		foreach ($options as $optionName => $optionValue) {

			if (isset($this->_options[$optionName])) {
				// it's valid. Set class property to its value.
				$this->_options[$optionName] = $optionValue;

			} //(if (isset($this->_validOptions[$optionName])))
		} //(foreach ($options as $optionName=>$propertyName))

	}//(setToolkitServiceParameters)

	// shorthand for getToolkitServiceParam()
	public function getOption($optionName) {
		return $this->getToolkitServiceParam($optionName);
	}//(getOption)

	// shorthand for setToolkitServiceParams()
	public function setOptions($options = array()) {
		$this->setToolkitServiceParams($options);

	}//(setOptions)

	// get a single option value
	public function getToolkitServiceParam($optionName) {

		// return property value if property is set.
		// we use array_key_exists() rather than isset() because the value may be null.

		// special case, case sensitivity
		if ($optionName == 'InternalKey') {
			$optionName = 'internalKey';
		}//(	if ($optionName == 'InternalKey'))

		if (array_key_exists($optionName, $this->_options)) {
			return $this->_options[$optionName];
		}//(if (array_key_exists($optionName, $this->_options))

		// nothing matched
		Throw new Exception("Invalid option requested: $optionName");

	}//(public function getToolkitServiceParam( $paramName ))

	// end job if private job (internal key set); end DB transport if not persistent.
	public function disconnect() {
		$this->PgmCall("OFF", NULL);

		if (isset($this->db) && $this->db) {
			$this->db->disconnect($this->conn);
		}
		$this->conn = null;
	}//(public function disconnect())

	// same as disconnect but also really close persistent database connection.
	public function disconnectPersistent() {
		$this->PgmCall("OFF", NULL);

		if (isset($this->db) && $this->db) {
			$this->db->disconnectPersistent($this->conn);
		}
		$this->conn = null;
	}//(public function disconnectPersistent())

	public function debugLog($stringToLog) {

		if ($this->isDebug()) {
			error_log("$stringToLog", 3, // means append
			$this->getOption('debugLogFile'));
		} //(debug)

	}//(debugLog)

	public function isDb2() {
		return $this->db2;
	}

	public function setDb2() {
		return $this->db2 = true;
	}

	// for special requests such as transport, performance, license
	public function specialCall($callType) {
		$this->setOptions(array($callType => true));
		$outputArray = $this->PgmCall("NONE", NULL, NULL, NULL);
		$this->setOptions(array($callType => false));

		return $outputArray;

	}//(specialCall)

	public function callTransportOnly() {
		return $this->specialCall('transport');
	}

	public function performanceData() {
		return $this->specialCall('performance');
	}

	// return license/version information
	public function licenseXMLSERVICE() {
		return $this->specialCall('license');
	}

	/* pgmCall
	 * @param string        pgmName     Name of program to call, without library
	 * @param string        lib         Library of program. Leave blank to use
	 * library list or current library
	 * @param array|string  InputParam  An array of ProgramParameter objects OR XML
	 * representing params, to be sent as-is.
	 * @param array|ProgramParameter    ReturnValue Array of one parameter that's the
	 * return value parameter
	 * @param array         options     Array of other options. The most popular is
	 * 'func' indicating the name of a subprocedure or function.
	 */
	public function pgmCall($pgmName, $lib, $inputParam = NULL, $returnParam = NULL, $options = NULL) {

		$this->cpfErr = '';
		$this->error = '';
		$this->joblog = '';
		$disconnect = false;
		$optional = false;
		$function = NULL;
		ProgramParameter::initializeFallbackVarName();
		// in case any data elements don't have names

		// If only one 'return' param, turn it into an array for later processing.
		if ($returnParam instanceof ProgramParameter) {
			$returnParam = array($returnParam);
		}//(// If only one 'return' param, turn it into an array for later processing.)

		$this->XMLWrapper = new XMLWrapper( array('encoding' => $this->getOption('encoding')), $this);

		// $optional handles special requests such as 'license'
		$disconnect = (strcmp($pgmName, "OFF") === 0) ? true : false;
		$optional = (strcmp($pgmName, "NONE") === 0) ? true : false;

		$outputParamArray = false;

		if (isset($options['func']))/*call service program*/
			$function = $options['func'];

		if ($disconnect || $optional) {
			// disconnect
			$inputXml = $this->XMLWrapper->disconnectXMLIn();
		} else {
			// regular request
			$inputXml = $this->XMLWrapper->buildXmlIn($inputParam, $returnParam, $pgmName, $lib, $function);
		}//(if( $disconnect || $optional))

		// send XML to XMLSERVICE
		$outputXml = $this->sendXml($inputXml, $disconnect);

		// there should be some output, even if only an error
		if ($outputXml != '') {

			// see if real data came back
			$outputParamArray = $this->XMLWrapper->getParamsFromXml($outputXml);

			// did we get results (array of regular in/out parms and return parms) ?
			if (!is_array($outputParamArray)) {

				// No real data. Look for errors. Retrieve details from joblog.
				$this->joblog = $this->XMLWrapper->getLastJoblog();

				// get CPF messages
				// Also store full msg in toolkit log

				// include called program in list of pgms that might have generated a CPF error
				// also include '< lveContext' because it may appear in the program spot if
				// library does not exist.
				// same for     '#mnrnrl' if program does not exist.
				// and          'QRNXIE' for non-numeric data passed in numeric field.
				// and          '< allProgram' for when wrong number of params are passed.
				// TODO instead of all these pseudo-program names, take last error from
				// XMLSERVICE parsing, if program name itself not found.
				$programsToLookFor = array(
					$pgmName,
					'< lveContext',
					'#mnrnrl',
					'QRNXIE',
					'< allProgram'
				);
				// make $pgmname the first item in the array

				if (isset($this->_cpfMapping[$pgmName])) {
					/* list of programs, in addition to the program that was called directly,
					 * that might generate CPF codes in joblog.
					 */
					// add them to the mix
					// use array_merge because it discards indexes
					$programsToLookFor = array_merge($programsToLookFor, $this->_cpfMapping[$pgmName]);

				}//(if other cpf-making programs)

				// put values in $this->cpfErr and $this->error
				$gotErrors = $this->extractErrorFromJoblog($programsToLookFor);

			} //(if( !is_array($OutputParamArray )))

			// if got real parms back
		}//(if($outputXml != ''))

		unset($this->XMLWrapper);

		// output array includes in/out parameters and return parameters.
		return $outputParamArray;

	}//(function pgmCall)

	// __toString will help people accustomed to outputting a resource as string
	// and for testing
	public function __toString() {
		$ipc = trim($this->getInternalKey());
		$serviceLibrary = $this->getOption('XMLServiceLib');
		$stringStart = "ToolkitService object using service library $serviceLibrary.";
		$ipcInfo = ($ipc) ? "Internalkey: '$ipc'" : "Running stateless (inline, no IPC).";

		return "$stringStart $ipcInfo";

	}//(__toString)

	public function getErrorMsg() {
		return $this->errorText;
	}

	public function getErrorCode() {
		return $this->cpfErr;
	}

	public function getOutputParam(array $OutputArray) {
		if (!is_array($OutputArray))
			return false;

		if (isset($OutputArray['io_param']))
			return $OutputArray['io_param'];

		return false;
	}

	// Send any XML to XMLSERVICE toolkit. The XML doesn't have to represent a
	// program.
	// Was protected; made public to be usable by applications.
	public function ExecuteProgram($inputXml, $disconnect = false) {

		$outputXml = '';
		$this->error = '';

		$this->VerifyPLUGName();
		// calculates value of option 'plug'
		$this->VerifyInternalKey();

		// TODO create driver-specific SQL in driver classes (db2, odbc)
		$toolkitLib = $this->getOption('XMLServiceLib');
		$internalKey = $this->getInternalKey();
		$controlKeyString = $this->getControlKey($disconnect);

		$plugSize = $this->getOption('plugSize');

		$transportType = $this->getOption('transportType');

		// TODO have one transport class that includes db as well.

		// If a database transport
		if (isset($this->db) && $this->db) {

			$schemaSep = $this->getOption('schemaSep');

			$plugPrefix = $this->getOption('plugPrefix');
			// construct plug name from prefix + size
			$plug = $plugPrefix . $plugSize;
			// e.g. iPLUG512K

			if ($plugPrefix == 'iPLUG') {
				// db2 driver stored procedures take 4 params
				$sql = "call {$toolkitLib}{$schemaSep}{$plug}(?,?,?,?)";
			} else {/*odbc, iPLUGR */
				// only three params for odbc stored procedures
				$sql = "call {$toolkitLib}{$schemaSep}{$plug}(?,?,?)";

			}//(if( $plugPrefix == 'iPLUG'))

			$bindArray = array(
				"internalKey" => $internalKey,
				"controlKey" => $controlKeyString,
				"inputXml" => $inputXml,
				"outputXml" => '',
				"disconnect" => $disconnect
			);
			//($bindArray)

			// if debug mode, log control key, stored procedure statement, and input XML.
			if ($this->isDebug()) {
				$this->debugLog("\nExec start: " . date("Y-m-d H:i:s") . "\nVersion of toolkit front end: " . self::getFrontEndVersion() . "\nIPC: '" . $this->getInternalKey() . "'. Control key: $controlKeyString\nStmt: $sql with transport: $transportType\nInput XML: $inputXml\n");
				$start = microtime(true);
			}//(if debug)

			// can return false if prepare or exec failed.
			$outputXml = $this->db->execXMLStoredProcedure($this->conn, $sql, $bindArray);

		} else {
			// Not a DB transport. At this time, assume HTTP transport (which doesn't use a
			// plug, by the way. uses outbytesize)
			$transport = $this->getTransport();
			$transport->setIpc($internalKey);
			$transport->setCtl($controlKeyString);
			$url = $this->getOption('httpTransportUrl');
			$transport->setUrl($url);

			// convert plugSize to bytes
			$outByteSize = $this->plugSizeToBytes($plugSize);

			// if debug mode, log control key, and input XML.
			if ($this->isDebug()) {
				$this->debugLog("\nExec start: " . date("Y-m-d H:i:s") . "\nVersion of toolkit front end: " . self::getFrontEndVersion() . "\nIPC: '" . $this->getInternalKey() . "'. Control key: $controlKeyString\nHost URL: $url\nExpected output size (plugSize): $plugSize or $outByteSize bytes\nInput XML: $inputXml\n");
				$start = microtime(true);
			}//(if debug)

			$outputXml = $transport->send($inputXml, $outByteSize);

		}//(if (isset($this->db) && $this->db))

		if ($this->isDebug() && $outputXml) {
			$end = microtime(true);
			$elapsed = $end - $start;
			$this->debugLog("Output XML: $outputXml\nExec end: " . date("Y-m-d H:i:s") . ". Seconds to execute: $elapsed.\n\n");
		}//(if debug and there's some output XML)

		// if false returned, was a database error (stored proc prepare or execute error)
		// TODO add ODBC SQL State codes

		// If can't find stored proc for ODBC: Database code (if any): S1000. Message:
		// [unixODBC][IBM][System i Access ODBC Driver][DB2 for i5/OS]SQL0440 - Routine
		// IPLUG512K in XMLSERVICE not found with specified parameters.
		//Warning: odbc_prepare(): SQL error: [unixODBC][IBM][System i Access ODBC
		// Driver][DB2 for i5/OS]SQL0440 - Routine IPLUG512K in XMLSERVICE not found with
		// specified parameters., SQL state S1000 in SQLPrepare in
		// /usr/local/zend/ToolkitAPI/Odbcsupp.php on line 89
		if ($outputXml === false) {
			$this->cpfErr = $this->db->getErrorCode();
			// actually SQL State
			$this->error = $this->db->getErrorMsg();

			$serviceLibrary = $this->getOption('XMLServiceLib');
			if ($this->cpfErr == 22003) {
				//22003 = On db2_execute, plug was too small to get output XML.
				$plug = $this->getOption('plug');
				$errorReason = "Error: Most likely, XML was too large for the current plug size. Plug: '$plug'.";
			} elseif ($this->cpfErr == 22501) {
				//22501 = Probably missing the LOB DB2 PTF. Get the latest DB2 Group PTF or CUME.
				// or individual PTF:
				//        V5R4: 5722SS1 SI39610
				//         6.1: 5761SS1 SI39829
				//         7.1: 5770SS1 SI39831/SI39917
				$errorReason = "Error: http://forums.zend.com/viewtopic.php?f=113&t=45413 Message: {$this->error}.";
			} elseif ($this->cpfErr == 38501) {
				// SQLState 38501: error in stored procedure. Possibly trace=true but library
				// XMLSERVLOG doesn't exist.
				//          or     Trigger program or external routine detected an error.
				// SQLCODE=-443
				$errorReason = "Error: SQLState 38501. Message: {$this->error}. Error in stored procedure or program. Could be a library that does not exist. If trace=true (not debug--trace), make sure XMLSERVLOG exists.";
			} elseif ($this->cpfErr == 42704) {
				//42704 = obj not found
				$errorReason = "Error: Toolkit not found in specified service library ($serviceLibrary).";
			} elseif ($this->cpfErr == 42833) {
				//42833 = The qualified object name is inconsistent with the naming option.
				$errorReason = "Error: i5_naming mismatch. When connecting to the toolkit, you specified i5_naming='$this->_i5NamingFlag' (or left the default of 0), which does not match the naming mode of the database job. Solution: If you are using a persistent database connection, ensure that every time you connect to db2 or the toolkit with a given user profile, you specify the same naming value for 'i5_naming'. If you are using library lists or a schema separator of '/', the naming mode must be '1'.";
			} elseif ($this->cpfErr == 58004) {
				//58004 = The qualified object name is inconsistent with the naming option.
				$errorReason = "Error:  Message: {$this->error}. SQLState 58004. If SQLCode is -901, check previous messages in joblog. Could mean an incorrect library in library list or another previous error in database job.";
			} else {
				$errorReason = "Toolkit request failed. Possible reason: a CCSID not matching that of system, or updated PTFs may be required.";
				$errorReason .= " Database code (if any): {$this->cpfErr}. Message: {$this->error}";
			}
			//(if error == 42704)

			// other codes: SQLState 38501: error in stored procedure. Possibly trace=true
			// but library XMLSERVLOG doesn't exist.
			//                       38501: Trigger program or external routine detected an
			// error. SQLCODE=-443
			//                              could be bad library in libl.
			//    in joblog, see:
			/* CPF2110  Library GLUMP not found.
			 * then:
			 * SQL0443 Message . . . . :   Trigger program or external routine detected an
			 * error.

			 Cause . . . . . :   Either a trigger program, external procedure, or external
			 function detected and returned an error to SQL. If the error occurred in a
			 trigger program, the trigger was on table QCMDEXC in schema QSYS. If the
			 error occurred in an external procedure or function, the external name is
			 QCMDEXC in schema QSYS.  The associated text is Library GLUMP not found..
			 If the error occurred in a trigger program, the associated text is the type
			 of trigger program.  If the error occurred in an external function, the
			 associated text is the text of the error message returned from the external
			 function.
			 */
			logThis($errorReason);
			die($errorReason);

		}//(if($outputXml === false) )

		if ($disconnect) {
			$this->db->disconnect($this->conn);

			if ($this->isDebug()) {
				$this->debugLog("Db disconnect requested and done.\n");
			} //(debug)
		}//(disconnect)

		// workaround: XMLSERVICE as of 1.7.4 returns a single space instead of empty
		// string when no content was requested.
		if ($outputXml == ' ') {
			$outputXml = '';
		}//(if ($outputXml == ' '))

		return $outputXml;

	}//(ExecuteProgram)

	// Alias of ExecuteProgram();
	// Send any XML to XMLSERVICE toolkit. The XML doesn't have to represent a
	// program.
	// Return output XML.
	// TODO create method to parse XML appropriately no matter what type of tags
	// (cmd/pgm etc.)
	public function sendXml($inputXml, $disconnect = false) {
		return $this->ExecuteProgram($inputXml, $disconnect);

	}//(sendRequest)

	// factory pattern.
	protected function getXmlWrapper() {
		return new XMLWrapper( array('encoding' => $this->getOption('encoding')), $this);
	}//(protected function getXmlWrapper())

	// $info can be 'joblog' (joblog and additional info) or 'conf' (if custom config
	// info set up in PLUGCONF)
	// Return array of version, joblog, job info
	public function getDiagnostics($info = 'joblog', $jobName = '', $jobUser = '', $jobNumber = '') {
		$xmlWrapper = $this->getXmlWrapper();

		$inputXml = $xmlWrapper->diagnosticsXmlIn($info, $jobName, $jobUser, $jobNumber);

		// set stored procedure "plug"
		$this->verifyPLUGName();

		// send the XML, running the command
		$outputXml = $this->sendXml($inputXml, false);

		if ($outputXml) {

			$this->cpfErr = 0;
			$this->error = '';

			return $xmlWrapper->parseDiagnosticsXml($outputXml);

		} else {

			// error or no info
			$this->cpfErr = $this->XMLWrapper->getErrorCode();
			$this->error = $this->cpfErr;
			// ->error is ambiguous. Include for backward compat.
			$this->errorText = $this->XMLWrapper->getErrorMsg();
			return false;

		} //(if ($outputXml) )

		// get status: error or success, with a real CPF error message, and set the error
		// code/msg.
		//        $successFlag = $this->XMLWrapper->getCmdResultFromXml( $outputXml,
		// $parentTag);

	}//(public function getDiagnostics)

	/**
	 * Return version number of the PHP toolkit (front-end).
	 * @return string  Version number (e.g. '1.4.0')
	 */
	static function getFrontEndVersion() {
		return self::VERSION;

	}//(static function getFrontendVersion())

	// return version number of XMLSERVICE. Not static because must connect to
	// back-end to get the version number.
	public function getBackEndVersion() {

		$diag = $this->getDiagnostics();

		if (isset($diag['version'])) {
			return $diag['version'];
		} else {
			return false;
		} //(if (isset($diag['version'])))

	}//(public function getBackendVersion())

	// exec could be 'pase', 'pasecmd', 'system,' 'rexx', or 'cmd'
	// $command can be a string or an array of multiple commands
	public function CLCommand($command, $exec = '') {

		$this->XMLWrapper = new XMLWrapper( array('encoding' => $this->getOption('encoding')), $this);

		$this->cpfErr = '0';
		$this->error = '';
		$this->errorText = '';

		$inputXml = $this->XMLWrapper->buildCommandXmlIn($command, $exec);

		// rexx and pase are the ways we might get data back.
		$expectDataOutput = in_array($exec, array(
			'rexx',
			'pase',
			'pasecmd'
		));

		// if a PASE command is to be run, the tag will be 'sh'. Otherwise, 'cmd'.
		if ($exec == 'pase' || $exec == 'pasecmd') {
			$parentTag = 'sh';
		} else {
			$parentTag = 'cmd';
		}//(if ($exec == 'pase' || $exec = 'pasecmd'))

		$this->VerifyPLUGName();

		// send the XML, running the command
		$outputXml = $this->sendXml($inputXml, false);

		// get status: error or success, with a real CPF error message, and set the error
		// code/msg.
		$successFlag = $this->XMLWrapper->getCmdResultFromXml($outputXml, $parentTag);

		if ($successFlag) {
			$this->cpfErr = 0;
			$this->error = '';
		} else {
			$this->cpfErr = $this->XMLWrapper->getErrorCode();
			$this->error = $this->cpfErr;
			// ->error is ambiguous. Include for backward compat.
			$this->errorText = $this->XMLWrapper->getErrorMsg();
		}//(if ($successFlag))

		if ($successFlag && $expectDataOutput) {

			// if we expect to receive data, extract it from the XML and return it.
			$outputParamArray = $this->XMLWrapper->getRowsFromXml($outputXml, $parentTag);

			unset($this->XMLWrapper);
			return $outputParamArray;
		} else {
			// don't expect data. Return true/false (success);
			unset($this->XMLWrapper);
			return $successFlag;
		} //(if success and expect data)

	}//(CLCommand)

	public function CLInteractiveCommand($command) {

		return $this->CLCommand($command, 'pase');
	}

	public function paseCommand($command) {

		return $this->CLCommand($command, 'pasecmd');
	}

	public function qshellCommand($command) {

		// send a command through the QSH interpreter
		// and interpret error results.

		// Handle errors and combine array-based results into a single string.

		// TODO consider doubling user-supplied single quotes to escape them in QSH

		$qshCommand = "QSH CMD('$command')";

		// will return an array of results.
		$resultArray = $this->CLInteractiveCommand($qshCommand);

		if (empty($resultArray) || !is_array($resultArray)) {
			logThis("Result of QSH command $qshCommand is empty or not an array.");
			return false;
		}

		// get status line
		$firstLine = trim($resultArray[0]);

		/* possible first line:
		 * QSH0005: Command ended normally with exit status 0.  [means A-OK]
		 * QSH0005: Command ended normally with exit status 1.  [look for a CPF message
		 * in next line]
		 * QSH0005: Command ended normally with exit status 127. [problem finding
		 * command]
		 * QSH0006: Command was ended by signal number yyy
		 * QSH0007: Command was ended by an exception [haven't seen this one yet]
		 */

		$qshCode = substr($firstLine, 0, 7);

		switch ($qshCode) {

			case 'QSH0005':
				// get status code.
				// String will be something like: QSH0005: Command ended normally with exit
				// status 1.
				// But in German: Befehl wurde normal mit Ausf�hrungsstatus &1 beendet.
				// look for a space (\b is word boundary), then the number, then a period OR
				// another word boundary.
				$pattern = '/\b([\d]+)[\b\.]/';
				// look for a match
				$numMatches = preg_match($pattern, $firstLine, $matches);
				if ($numMatches) {
					$exitStatus = $matches[1];
					// replacement parenthetical bit, i.e. the number.
				} else {
					$this->cpfErr = $qshCode;
					$this->error = 'Could not get exit code. Check toolkit error log for error.';
					logThis("Result of QSH command $qshCommand was error: $firstLine.");
					return false;
				}

				if ($exitStatus == '0') {

					// SUCCESS!!!
					// everything is fine.
					// Return the rest of the array (without the status line).
					if (count($resultArray) > 1) {
						return array_slice($resultArray, 1);
					} //(count > 1)

				} else {
					// look for a CPF code in second line. May not always be there.
					// will resemble: catsplf: 001-2003 Error CPF3492 found processing spool file
					// QSYSPRT, number 2.
					//            or: catsplf: 001-2373 Job 579272/QTMHHTP1/WSURVEY400 was not
					// found."
					//
					// TODO extract CPF code.
					// TODO distinguish between status 1 and 127, if helpful
					if (isset($resultArray[1])) {
						$secondLine = trim($resultArray[1]);
						$this->cpfErr = $secondLine;
						return false;
					}
				}//(exitStatus)
				/*} elseif ($exitStatus == '127') {
				 // look for errmsg in second line (e.g. cannot find command)
				 } //(if $exitStatus)
				 */

				break;

			case 'QSH0006':
			case 'QSH0007':
				$this->cpfErr = $qshCode;
				$this->error = 'Check toolkit error log for error.';
				logThis("Result of QSH command $qshCommand was error: $firstLine.");
				return false;
				break;
		} //(switch $qshcode)

	}//(qshellCommand)

	// new. uses REXX to return output params and CPF codes
	// Slower than 'cmd' or 'system'
	// Sample format of command: 'RTVJOBA JOB(?) USER(?) NBR(?) CURUSER(?) SYSLIBL(?)
	// CURLIB(?) USRLIBL(?) LANGID(?) CNTRYID(?) CCSID(?N) DFTCCSID(?N)'
	public function ClCommandWithOutput($command) {

		return $this->CLCommand($command, 'rexx');
	}//(ClCommandWithOutput)

	// new. uses 'system' to return CPF codes
	// slightly slower than regular cmd but faster than rexx
	// (Actually it's faster than cmd in recent tests. It depends, perhaps.)
	// $command can be a string or an array.
	public function ClCommandWithCpf($command) {

		return $this->CLCommand($command, 'system');
	}//(ClCommandWithCpf)

	static function AddParameter($type, $io, $comment, $varName = '', $value, $varying = 'off', $dimension = 0) {
		return array(
			'type' => $type, // storage
			'io' => $io, // in/out/both
			'comment' => $comment, // comment
			'var' => $varName, // variable name
			'data' => $value, // value
			'varying' => $varying, // varying on/varying off
			'dim' => $dimension
		);
		// number of array elements
	}

	static function AddParameterChar($io, $size, $comment, $varName = '', $value, $varying = 'off', $dimension = 0, $by = '', $isArray = false, $ccsidBefore = '', $ccsidAfter = '', $useHex = false) {
		return (new CharParam($io, $size, $comment, $varName, $value, $varying, $dimension, $isArray, $ccsidBefore, $ccsidAfter, $useHex));
	}

	static function AddParameterInt32($io, $comment, $varName = '', $value, $dimension = 0) {
		return (new Int32Param($io, $comment, $varName, $value, $dimension));
	}

	//Size ($comment,  $varName = '', $labelFindLen = null) {
	static function AddParameterSize($comment, $varName = '', $labelFindLen) {
		return (new SizeParam($comment, $varName, $labelFindLen));
	}

	//SizePack5 ($comment,  $varName = '', $labelFindLen = null) {
	static function AddParameterSizePack($comment, $varName = '', $labelFindLen) {
		return (new SizePackParam($comment, $varName, $labelFindLen));
	}

	static function AddParameterInt64($io, $comment, $varName = '', $value, $dimension = 0) {
		return (new Int64Param($io, $comment, $varName, $value, $dimension));
	}

	static function AddParameterUInt32($io, $comment, $varName = '', $value, $dimension = 0) {
		return (new UInt32Param($io, $comment, $varName, $value, $dimension));
		// removed erroneous "off"
	}

	static function AddParameterUInt64($io, $comment, $varName = '', $value, $dimension = 0) {
		return (new UInt64Param($io, $comment, $varName, $value, $dimension));

	}

	static function AddParameterFloat($io, $comment, $varName = '', $value, $dimension = 0) {
		return (new FloatParam($io, $comment, $varName, $value, $dimension));
	}

	static function AddParameterReal($io, $comment, $varName = '', $value, $dimension = 0) {
		return (new RealParam($io, $comment, $varName, $value, $dimension));
	}

	static function AddParameterPackDec($io, $length, $scale, $comment, $varName = '', $value, $dimension = 0) {
		return (new PackedDecParam($io, $length, $scale, $comment, $varName, $value, $dimension));
	}

	static function AddParameterZoned($io, $length, $scale, $comment, $varName = '', $value, $dimension = 0) {
		return (new ZonedParam($io, $length, $scale, $comment, $varName, $value, $dimension));
	}

	// "hole" paramter is for data to ignore
	static function AddParameterHole($size, $comment = 'hole') {
		return (new HoleParam($size, $comment));
	}

	static function AddParameterBin($io, $size, $comment, $varName = '', $value, $dimension = 0) {
		return (new BinParam($io, $size, $comment, $varName, $value, $dimension));
	}

	static function AddParameterArray($array) {
		foreach ($array as $element) {
			$params[] = self::AddParameter($element['type'], $element['io'], $element['comment'], $element['var'], $element['data'], $element['varying'], $element['dim']);
		}
		return $params;
	}

	static function AddDataStruct(array $parameters, $name = 'struct_name', $dim = 0, $by = '', $isArray = false, $labelLen = null, $comment = '') {
		return (new DataStructure($parameters, $name, $dim, $comment, $by, $isArray, $labelLen));
	}

	// added.
	static function AddErrorDataStruct() {
		return (new DataStructure(self::GenerateErrorParameter(), 'errorDs', 0));
	}

	// use this one when you need a zero-byte error structure,
	// which is useful to force errors to bubble up to joblog,
	// where you can get more information than in the structure.
	static function AddErrorDataStructZeroBytes() {
		return (new DataStructure(self::GenerateErrorParameterZeroBytes(), 'errorDs', 0));
	}

	// pure XML version
	// Pass in $paramNum to get a numeric parameter number for the comment.
	/*	static function getErrorDataStructXml($paramNum = 0) {
	 $paramNumStr = ($paramNum) ? ($paramNum . '.') : '';
	 return "<parm io='both' comment='$paramNumStr Error code structure'>
	 <ds var='errorDs'>
	 <data var='errbytes' type='10i0' comment='Size of DS'>144</data>
	 <data var='err_bytes_avail' type='10i0' comment='if non-zero, an error occurred'
	/>
	 <data var='exceptId' type='7A' varying='off' comment='CPF code'>0000000</data>
	 <data var='reserved' type='1h' varying='off' />
	 <data var='excData' type='128a' varying='off' comment='replacement data. Not
	sure we want it. Causes problems in XML.' />
	 </ds>
	 </parm>";
	 }
	 */
	// use a zero (0) bytes length to force errors to bubble up to job. It's easier
	// for us to get full message text from joblog that XMLSERVICE toolkit provides.
	// Anyway, the QSNDDTAQ API doesn't have an error struct, so this way we can be
	// consistent---get all errors in joblog.
	static function getErrorDataStructXml($paramNum = 0) {
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';
		return "<parm io='both' comment='$paramNumStr Error code structure'>
                 <ds var='errorDs'>
                   <data var='errbytes' type='10i0' comment='Size of DS. Use 0 to force errors to bubble up to the job'>0</data>
                 </ds>
              </parm>";
	}

	// this DS is common to many IBM i APIs.
	static function getListInfoApiXml($paramNum = 0) {
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

		return "<parm io='out' comment='$paramNumStr List information'>
		    <ds var='listinfo' comment='Open list information format (common to all lists)'>
		     <data var='totalRecords' comment='Total records' type='10i0' />
		     <data var='returnedRecords' comment='Records returned' type='10i0' />
		     <data var='requestHandle' comment='Request handle: binary/hex' type='4b' />
		     <data var='recordLength' comment='Record length' type='10i0' />
		     <data var='infoComplete' comment='Information complete indicator. C=complete, I=incomplete, P=partial, more to get in Get List Entries' type='1a' />
		     <data var='timeAndDateCreated' comment='Time and date created' type='13a' />
		     <data var='listStatus' comment='List status indicator' type='1a' />
		     <data var='reserved' comment='Reserved' type='1h' />
		     <data var='lengthReturned' comment='Length of information returned' type='10i0' />
		     <data var='firstRecordNumber' comment='Number of first record returned in receiver variable' type='10i0' />
		     <data var='reserved2' comment='Reserved (another one)' type='40h' />
		    </ds>
		  </parm>";
	}//(getListApiXml)

	// this DS is common to many IBM i APIs.
	static function getNumberOfRecordsDesiredApiXml($paramNum = 0) {
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

		return "<parm io='in' comment='$paramNumStr Number of records to return. Use zero to offload to Get List Entries API'>
                  <data var='numRecsDesired' type='10i0'>0</data>
                </parm>";
	}//(getNumberOfRecordsDesiredApiXml)

	// this DS is common to many IBM i APIs.
	static function getSortInformationApiXml($paramNum = 0) {
		$paramNumStr = ($paramNum) ? ($paramNum . '.') : '';

		// assume no sort is required. Could add a sort in future if needed.
		return "<parm io='in' comment='$paramNumStr Sort information' >
                 <ds var='sortInfo'>
                   <data var='numSortKeys' comment='Number of keys to sort on. Use zero' type='10i0'>0</data>
                 </ds>
               </parm>
		";
	}//(getSortInformationApiXml)

	// this DS is common to many IBM i APIs.
	static function getDummyReceiverAndLengthApiXml($paramNum = 1, $lengthOfReceiverVariable) {
		$paramNumStr = $paramNum . '.';
		$paramNumStrNext = ($paramNum + 1) . '.';

		// assume no sort is required. Could add a sort in future if needed.
		return "<parm io='out' comment='$paramNumStr receiver. do not actually receive anything here. Wait till Get List Entry'>
                  <ds var='receiver' comment='length $lengthOfReceiverVariable'>
                    <data type='1h' comment='dummy. Real receiver will be gotten in list entry API call' />
                  </ds>
                </parm>
                <parm io='in' comment='$paramNumStrNext Length of receiver variable (actual structure to be given in Get List Entry)'>
                  <data var='receiverLen' type='10i0' comment='length $lengthOfReceiverVariable'>$lengthOfReceiverVariable</data>
                </parm>";
	}//(getSortInformationApiXml)

	public function getLastError() {
		return $this->error;
	}

	public function isError() {
		if ($this->error != '')
			return true;
		return false;
	}

	public function getInternalKey() {
		return $this->getOption('internalKey');
	}

	public function isStateless() {
		return $this->getOption('stateless');
	}

	public function setInternalKey($internalKey) {
		$this->setOptions(array('internalKey' => $internalKey));
	}

	// construct a string of space-delimited control keys based on properties of this
	// class.
	protected function getControlKey($disconnect = false) {

		$key = '';
		// initialize

		if ($disconnect) {
			return "*immed";
		}
		/*
		 if(?) *justproc
		 if(?) *debug
		 if(?) *debugproc
		 if(?) *nostart
		 if(?) *rpt*/

		// Idle timeout supported by XMLSERVICE 1.62
		// setting idle for *sbmjob protects the time taken by program calls
		// Do that with *idle(30/kill) or whatever the time in seconds.
		if (trim($this->getOption('idleTimeout')) != '') {
			$idleTimeout = $this->getOption('idleTimeout');
			$key .= " *idle($idleTimeout/kill)";
			// ends idle only, but could end MSGW with *call(30/kill)
		}

		// if cdata requested, request it. XMLSERVICE will then wrap all output in CDATA
		// tags.
		if ($this->getOption('cdata')) {
			$key .= " *cdata";
		}

		/* stateless calls in stored procedure job
		 *
		 * Add *here, which will run everything inside the current PHP/transport job
		 * without spawning or submitting a separate XTOOLKIT job.
		 */
		if ($this->isStateless()) {
			$key .= " *here";

		} else {
			// not stateless, so could make sense to supply *sbmjob parameters for spawning a
			// separate job.
			if (trim($this->getOption('sbmjobParams')) != '') {
				$sbmjobParams = $this->getOption('sbmjobParams');
				$key .= " *sbmjob($sbmjobParams)";
			} //(if subsystem *sbmjob specified)

		}//(if stateless)

		// if internal XMLSERVICE tracing, into database table XMLSERVLOG/LOG, is desired
		if ($this->getOption('trace')) {
			$key .= " *log";
		}//(if ($this->_trace))

		// directive not to run any program, but to parse XML and return parsed output,
		// including dim/dou.
		if ($this->getOption('parseOnly')) {
			$key .= " *test";

			// add a debugging level (1-9) to the parse, to make *test(n) where n is the
			// debugging level
			if ($parseDebugLevel = $this->getOption('parseDebugLevel')) {
				$key .= "($parseDebugLevel)";
			} //(if ($this->_parseDebugLevel) )

		}//(if ($this->_trace))

		// return XMLSERVICE version/license information (no XML calls)
		if ($this->getOption('license')) {
			$key .= " *license";
		}//($this->getOption('license'))

		// check proc call speed (no XML calls)
		if ($this->getOption('transport')) {
			$key .= " *justproc";
		}//($this->getOption('transport'))

		// get performance of last call data (no XML calls)
		if ($this->getOption('performance')) {
			$key .= " *rpt";
		}//($this->getOption('performance'))

		// PASE CCSID for <sh> type of functions such as WRKACTJOB ('system' command in
		// PASE)
		if ($paseCcsid = $this->getOption('paseCcsid')) {
			$key .= " *pase($paseCcsid)";
		}//($this->getOption('performance'))

		// allow custom control keys
		if ($this->getOption('customControl')) {
			$key .= " {$this->getOption('customControl')}";
		}//($this->getOption('performance'))

		return trim($key);
		// trim off any extra blanks on beginning or end

	}//(getControlKey)

	//to set a plug name use function setToolkitServiceParams('plug'=>'iPLUGR512K')

	protected function VerifyPLUGName() {
		// if plug already set, don't need to set it now.
		if ($this->getOption('plug') != '') {
			return;
		}
		//Sets the default plug.
		$size = 512;
		$unit = 'K';
		//or M

		/*4K, 32K, 65K, 512K,
		 1M, 5M, 10M up to 15M ...*/

		//in case that following SQL error error:
		//Length in a varying-length or LOB host variable not valid. SQLCODE=-311
		//verify that all last blob ptfs are applied on i5 machine
		//set the $this->plug = "iPLUG4K";,
		//it calls the program that returns data via char storage
		$plug = $this->getOption('plugPrefix') . $size . $unit;
		$this->setOptions(array('plug' => $plug));

	}//(VerifyPLUGName)

	// Ensures that an IPC has been set. If not, generate one
	protected function verifyInternalKey() {
		// if we are running in stateless mode, there's no need for an IPC key.
		if ($this->isStateless()) {
			$this->setInternalKey('');
			return;
		}

		if (trim($this->getInternalKey()) == '') {
			if (session_id() != '')/*if programmer already started session, use it*/
				$this->setInternalKey("/tmp/" . session_id());
			else
				$this->setInternalKey("/tmp/" . $this->generate_name());
		}
	}//(verifyInternalKey())

	// was protected. Changed to public.
	// May be useful to access raw XML result
	// TODO make outputXml a property that is used so this method can work.
	public function getXmlOut() {
		return $this->outputXml;
	}

	// return transport object for toolkit
	public function getConnection() {
		return $this->conn;
	}

	public function generate_name() {/*move to i5 side*/
		$localtime = localtime();
		$rndName = sprintf("ZS%d%d%d%d", $localtime[0], /*s*/
		$localtime[1], /*min*/
		$localtime[2], /*our*/
		$localtime[3] /*day*/
		);
		return $rndName;
	}

	/*creates Data structure that going to be used in lot of
	 * i5 API's for error handling                         */
	static function GenerateErrorParameter() {
		$ErrBytes = 144;
		$ErrBytesAv = 144;
		$ErrCPF = '0000000';
		$ErrRes = ' ';
		$ErrEx = ' ';
		// changed $this to self so can work in static context
		$ds[] = self::AddParameterInt32('in', "Bytes provided", 'errbytes', $ErrBytes);
		$ds[] = self::AddParameterInt32('out', "Bytes available", 'err_bytes_avail', $ErrBytesAv);
		$ds[] = self::AddParameterChar('out', 7, "Exception ID", 'exceptId', $ErrCPF);
		$ds[] = self::AddParameterChar('out', 1, "Reserved", 'reserved', $ErrRes);
		$ds[] = self::AddParameterHole('out', 128, "Exception data", 'excData', $ErrEx);
		// can be bad XML so make it a hole
		return $ds;
	}

	// specify zero bytes so error bubbles up to joblog where we can get description,
	// etc.
	// TODO return 'in'-only data structure containing the int.
	static function GenerateErrorParameterZeroBytes() {
		$ErrBytes = 0;
		// changed $this to self so can work in static context
		$ds[] = self::AddParameterInt32('in', "Bytes provided (zero makes errors bubble up to joblog)", 'errbytes', $ErrBytes);
		return $ds;
	}

	public function verify_CPFError($retPgmArr, $functionErrMsg) {
		// it's an error if we didn't get output array at all
		// in that case, look for general "error" material

		// $functionErrMsg is obsolete now.

		if (!is_array($retPgmArr)) {
			$this->error = $this->getLastError();
			return true;
		}

		$retArr = $retPgmArr['io_param'];

		// get errorDs from named ds (CW style) or directly (PHP toolkit style)
		$errorDs = (isset($retArr['errorDs'])) ? $retArr['errorDs'] : $retArr;

		// If there's an error structure and some error info was returned.
		// (err_bytes_avail is the official, reliable way to check for an error.)
		if (isset($errorDs) && ($errorDs['err_bytes_avail'] > 0)) {
			$this->cpfErr = $errorDs['exceptId'];
			// TODO future, get actual error text from joblog
			$this->error = $functionErrMsg;
			return true;
			//some problem
		} else {
			// no CPF error detected.
			$this->cpfErr = '0000000';
			$this->error = '';
			return false;
		}
	}//(verify_CPFError)

	public function ParseErrorParameter(array $Error) {
		if (!is_array($Error))
			return false;

		// If there's an error structure and some error info was returned.
		// (err_bytes_avail is the official, reliable way to check for an error.)
		if (isset($Error['exceptId']) && ($Error['err_bytes_avail'] > 0)) {
			$CPFErr = $Error['exceptId'];
			/*Add here array parse if need */
		}
		return $CPFErr;
	}

	// for sql calls via already opened connection.
	// Clearer naming than existing getConnection();
	// TODO Probably even better would be a name such as getTransportConn() because
	// it could work for any transport type.
	public function getSQLConnection() {
		return $this->getConnection();
	}

	public function executeQuery($stmt) {
		$Txt = $this->db->executeQuery($this->getConnection(), $stmt);

		if (!is_array($Txt)) {

			$this->cpfErr = $this->db->getErrorCode();
			$this->error = $this->db->getErrorMsg();

			throw new Exception($this->error, $this->cpfErr);
		}
		return $Txt;
	}

	public function setIsPersistent($isPersistent = false) {
		if (is_bool($isPersistent)) {
			$this->_isPersistent = $isPersistent;
		} else {
			throw new Exception("setIsPersistent: boolean expected");
		}
	}//(setIsPersistent)

	public function getIsPersistent() {
		return $this->_isPersistent;
	}//(setIsPersistent)

	/* Method: getJobAttributes()
	 *
	 * Retrieve several attributes of the current job.
	 * Return array of attributes (key/value pairs) or false if unsuccessful.
	 * Purpose: 1. Helps user find toolkit job; identifies libraries and CCSID used
	 * by toolkit connection
	 *          2. The code is an example of how to get output from RTV* CL commands
	 * Sample output:
	 * Array(
	 [JOB] => QSQSRVR
	 [USER] => QUSER
	 [NBR] => 240164
	 [CURUSER] => QTMHHTTP
	 [SYSLIBL] => QSYS       QSYS2      QHLPSYS    QUSRSYS    DBU80      QSYS38
	 [CURLIB] => *NONE
	 [USRLIBL] => QTEMP      QGPL       MYUTIL
	 [LANGID] => ENU
	 [CNTRYID] => US
	 [CCSID] => 37
	 [DFTCCSID] => 37)
	 */
	public function getJobAttributes() {

		// Retrieve job attributes. Note: the CCSID attributes use (?N), not (?), because
		// they are numeric.
		$cmdString = 'RTVJOBA JOB(?) USER(?) NBR(?) CURUSER(?) SYSLIBL(?) CURLIB(?) USRLIBL(?) LANGID(?) CNTRYID(?) CCSID(?N) DFTCCSID(?N)';

		// Send the command; get output array of key/value pairs. Example: CURUSER=>FRED,
		// ...
		$outputArray = $this->ClCommandWithOutput($cmdString);

		return $outputArray;

	}//(public function getJobAttributes())

	/* classPath(). for diagnostics, return the file system absolute path of this
	 * script.
	 * Usage: echo 'The path of ToolkitService.php is: ' .
	 * ToolkitService::classPath();
	 * Sample output: The path of ToolkitService.php is:
	 * /usr/local/zendsvr/share/ToolkitApiDev-1.4.0/pre140/ToolkitService.php
	 */
	static function classPath() {
		return __FILE__;
	}//(static function classPath();

	/**
	 * given $this->joblog, and an array of program names that might have caused
	 * errors,
	 * Extract the error code (CPF or similar) and message text from the joblog.
	 * If can't find error in joblog, uses UNEXPECTED
	 *    and text from $this->XMLWrapper->getLastError();
	 *
	 * Code is placed in $this->cpfErr. Text goes to $this->error.
	 *
	 * @param array $programsToLookFor
	 * @return boolean    True on success, False on failure
	 */
	protected function extractErrorFromJoblog(array $programsToLookFor) {
		// CPF, CPC, CPE...
		// also get between
		/*Message . . . . :   Invalid length. MAXLEN for data queue NEWQ in CWDEMO is
		 128.
		 Cause . . . . . :  */

		// where we can find info in joblog
		$cpfOffset = 0;
		// first 7 chars is CPF
		$cpfLen = 7;

		$pgmOffset = 67;
		// program name found on same line as CPF code, offset 68
		$pgmLen = 12;
		// can be special '< lveContext' type names.

		$messageLabel = 'Message . . . . :';
		$messageLabelOffset = 37;
		// "Message . . . . :   "
		$messageLabelLen = strlen($messageLabel);

		$causeLabel = 'Cause . . . . . :';
		$recoveryLabel = 'Recovery  . . . :';

		// split on line feeds, then put in reverse order so that we'll get the latest
		// first
		$joblogLines = $lines = preg_split('/\r\n|\r|\n/', $this->joblog);
		// split on 0D0A etc.

		// in reverse order, look for line with program given/
		// "true" in array_reverse() keeps array index/record numbers intact.
		$startingLine = 0;
		foreach (array_reverse($joblogLines, true) as $lineNum => $lineString) {

			// Look for program name that we originally called.
			// Trim spaces from the right but not the left. (Need pgm name to START in
			// precise location)
			$substringAtProgramLocation = rtrim(substr($lineString, $pgmOffset, $pgmLen));

			if (in_array($substringAtProgramLocation, $programsToLookFor)) {
				$startingLine = $lineNum;
				break;

			}
		}//(foreach $joblogLines)

		if ($startingLine) {
			// we found a joblog entry for the program that we called.

			// first line of section has CPF code as well as program name.
			$firstLine = $joblogLines[$startingLine];

			// get the error code. We call it CPF but it could also be GUI, CPE, CPC....
			$cpfCode = substr($firstLine, $cpfOffset, $cpfLen);

			// go forward till we hit the end or till we come to a new CPF code (detect that
			// if find a fully 7-position string at start)
			$msgText = '';
			$startCollecting = false;
			// get rid of lines before starting line
			$joblogLines = array_slice($joblogLines, $startingLine);
			while (($lineString = next($joblogLines)) && ($lineString !== false) && (strpos($lineString, ' ', $cpfOffset) < $cpfLen)) {

				// but start collecting text when we find "Message" label.
				if (substr($lineString, $messageLabelOffset, $messageLabelLen) == $messageLabel) {
					$startCollecting = true;
				}

				if ($startCollecting) {

					// If not a heading (omit headings)
					/*
					 5761SS1 V6R1M0 080215                        Display Job Log
					SBSUSA   11/18/11 15:39:54          Page    2
					 Job name . . . . . . . . . . :   QSQSRVR         User  . . . . . . :   QUSER
					Number . . . . . . . . . . . :   815166
					 Job description  . . . . . . :   QDFTSVR         Library . . . . . :   QGPL
					 MSGID      TYPE                    SEV  DATE      TIME             FROM PGM
					LIBRARY     INST     TO PGM      LIBRARY     INST
					 */
					$lineLen = strlen($lineString);

					// Is a heading if one of the following are found. Use !== false because 0 is a
					// valid "found" result.
					// Check that line length is > 46 before checking for string in position 46, to
					// avoid warning in log
					$isHeadingLine = (($lineLen > 46 && (strpos($lineString, 'Display Job Log', 46) !== false)) || strpos($lineString, 'Job name', 2) !== false || strpos($lineString, 'Job description', 2) !== false || strpos($lineString, 'MSGID', 0) !== false);

					if (!$isHeadingLine) {
						// concatenate whole line. We will remove labels later
						$msgText .= ' ' . trim($lineString);
					} //(if not a heading line)

				} //(if $startCollecting)

			}//(while more lines)

			/*  Clean up $msgText.
			 *  Remove text labels and convert multiple spaces to single space
			 */
			$old = array(
				$messageLabel,
				$causeLabel,
				$recoveryLabel,
				'   ',
				'  '
			);
			$new = array(
				'',
				'',
				'',
				' ',
				' '
			);
			$cleanMsgText = str_replace($old, $new, $msgText);

			$this->cpfErr = $cpfCode;
			$this->error = trim($cleanMsgText);
			$this->errorText = trim($cleanMsgText);

		} else {

			// could not find it.
			// use error text from XML parser (though this text is usually worthless)
			$this->cpfErr = 'UNEXPECTED';
			$this->error = $this->XMLWrapper->getLastError();
			$this->errorText = $this->error;

		}//(if $startingLine)

		return true;

	}//( function extractErrorFromJoblog)

	/**
	 * changeCurrentUser (1.5.0+)
	 * Changes the current user of the job to a specific user. All actions will be
	 * executed as this user from now on.
	 * Otherwise known as "swap user" or the misnomer "adopt authority."
	 * @param string $user Generally should be uppercase
	 * @param string $password
	 * @return boolean  True on success, False on failure
	 */
	function changeCurrentUser($user, $password) {

		// Force user/pw to uppercase. (should they?)
		// Ask Support team for opinion on uppercase or not.
		$user = strtoupper($user);
		$password = strtoupper($password);

		// Get profile handle (checking u/p validity)
		// http://publib.boulder.ibm.com/infocenter/iseries/v5r4/index.jsp?topic=%2Fapis%2FQSYGETPH.htm
		$apiPgm = 'QSYGETPH';
		$apiLib = 'QSYS';

		$pwLen = strlen($password);
		$pwCcsid = '-1';
		// -1 means 37 or DFTCCSID depending on password level

		$params[] = $this->addParameterChar('in', 10, '1. user', 'user', $user);
		$params[] = $this->addParameterChar('in', 10, '2. password', 'pw', $password);
		$params[] = $this->addParameterBin('out', 12, '3. profile handle', 'handleOut');

		// use a zero (0) bytes length to force errors to bubble up to job. It's easier
		// for us to get full message text from joblog that XMLSERVICE toolkit provides.
		// As well, the QSNDDTAQ API doesn't have an error struct, so this way we can be
		// consistent---get all errors in joblog.
		$params[] = $this->addParameterInt32('both', 'Size of error DS. Use 0 to force errors to bubble up to the job', 'errbytes', '0');

		if (substr($password, 0, 1) != '*') {
			/* No asterisk at the start, so this is an attempt at a real password,
			 * not a special pw value starting with an asterisk such as *NOPWD, *NOPWDCHK, or
			 * *NOPWDSTS.
			 * Therefore, include pw len and CCSID, which must be omitted if pw is a special
			 * "*" value.
			 */
			$params[] = $this->addParameterInt32('both', '5. length of password. Must be equal to the actual pw length.	', 'pwLen', $pwLen);
			$params[] = $this->addParameterInt32('both', '6. CCSID of password', 'pwCcsid', $pwCcsid);

		}//(if (substr($password, 0, 1) != '*'))

		// now call the API, returning results.
		$retPgmArr = $this->PgmCall($apiPgm, $apiLib, $params, null);

		if ($this->getErrorMsg() || $this->getErrorCode()) {
			// problem--possibly user or password was wrong
			return false;
		}//(if ($this->getErrorMsg()...)

		// get handle from API we called.
		if (isset($retPgmArr['io_param']['handleOut'])) {
			$handle = $retPgmArr['io_param']['handleOut'];
			// handleOut defined in XML above
		}

		// if anything went wrong
		if (!isset($handle) || empty($handle)) {
			return false;
		}

		// now set the user profile via the handle.
		// http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=%2Fapis%2FQWTSETP.htm
		$apiPgm = 'QWTSETP';
		// set profile
		$apiLib = 'QSYS';

		// reset $params array for next API call
		$params = array();
		$params[] = $this->addParameterBin('in', 12, '1. profile handle', 'handleIn', $handle);
		// error ds param
		$params[] = $this->addParameterInt32('both', '2. Size of error DS. Use 0 to force errors to bubble up to the job', 'errbytes', '0');

		// now call the "set handle" API!
		$retPgmArr = $this->PgmCall($apiPgm, $apiLib, $params);

		// any errors?
		if ($this->getErrorMsg() || $this->getErrorCode()) {
			// problem--possibly user or password was wrong
			return false;
		}//(if ($this->getErrorMsg()...)

		// Now close/release the handle (handles are limited resources, about 20,000 per
		// job).
		// http://publib.boulder.ibm.com/infocenter/iseries/v7r1m0/index.jsp?topic=%2Fapis%2FQSYRLSPH.htm
		$apiPgm = 'QSYRLSPH';
		// release profile handle
		$apiLib = 'QSYS';

		// reset $params array for next API call
		$params = array();
		$params[] = $this->addParameterBin('in', 12, '1. profile handle', 'handleIn', $handle);
		// error ds param
		$params[] = $this->addParameterInt32('both', '2. Size of error DS. Use 0 to force errors to bubble up to the job', 'errbytes', '0');

		// now call the "release handle" API!
		$retPgmArr = $this->PgmCall($apiPgm, $apiLib, $params);

		// any errors?
		if ($this->getErrorMsg() || $this->getErrorCode()) {
			// problem--possibly user or password was wrong
			return false;
		}//(if ($this->getErrorMsg()...)

		return true;

	}//(function changeCurrentUser)

	// return value from toolkit config file,
	// or a default value, or
	// false if not found.
	static function getConfigValue($heading, $key, $default = null) {
		// TODO store in Zend Data Cache to avoid reading during each request

		// if we haven't read config file yet, do so.
		if (!isset(self::$_config)) {

			// read/stat INI once and only once per request
			self::$_config = parse_ini_file(CONFIG_FILE, true);
			// true means use headings
		}//(if (!isset(self::$_config)))

		if (isset(self::$_config[$heading][$key])) {
			return self::$_config[$heading][$key];
		} elseif (isset($default)) {
			return $default;
		} else {
			return false;
		}

	} //(getConfigValue)

}//(class ToolkitService)

// Class ends above.

// TODO integrate these functions into toolkit class. Back-ported from CW.

// keep non-OO functions for backward compatibility and CW support
function getConfigValue($heading, $key, $default = null) {
	return ToolkitService::getConfigValue($heading, $key, $default);

}//(function getConfigValue())

function logThis($msg) {
	$logFile = getConfigValue('log', 'logfile');
	if ($logFile) {
		// it's configured so let's write to it. ("3" means write to a specific file)
		$formattedMsg = "\n" . microDateTime() . ' ' . $msg;
		error_log($formattedMsg, 3, $logFile);
	}

}//(logThis)

function microDateTime() {
	list($microSec, $timeStamp) = explode(" ", microtime());
	return date('j M Y H:i:', $timeStamp) . (date('s', $timeStamp) + $microSec);
}
